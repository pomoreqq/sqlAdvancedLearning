1. SELF JOIN â€“ relacje przeÅ‚oÅ¼ony-pracownik

Masz tabelÄ™ employees:

id | name     | manager_id
--------------------------
1  | Anna     | NULL
2  | Bartek   | 1
3  | Celina   | 1
4  | Damian   | 2


ğŸ‘‰ Napisz zapytanie, ktÃ³re zwrÃ³ci imiÄ™ pracownika i imiÄ™ jego przeÅ‚oÅ¼onego w formacie

SELECT e.name AS employee, m.name AS manager 
FROM employees e 
INNER JOIN employees m 
ON e.manager_id = m.id


2. CROSS JOIN â€“ generowanie wszystkich kombinacji

Masz dwie tabele:

colors
-------
red
green
blue

sizes
------
S
M
L


SELECT color, size
FROM colors
CROSS JOIN sizes;

Masz dwie tabele:

likes_2024
------------
user_id
1
2
2
3

likes_2025
------------
user_id
2
3
4


ğŸ‘‰ Napisz dwa zapytania:

KtÃ³re zwrÃ³ci listÄ™ wszystkich user_id z obu tabel, z duplikatami

KtÃ³re zwrÃ³ci unikalne user_id
select user_id from likes_2024
union
select user_id from likes_2025

select user_id from likes_2024
union all
select user_id from likes_2025


ğŸ‘‰ Napisz zapytanie, ktÃ³re zwrÃ³ci:

imiÄ™ klienta

numer zamÃ³wienia

kwotÄ™
Tylko dla klientÃ³w z USA, ktÃ³rych zamÃ³wienie byÅ‚o na wiÄ™cej niÅ¼ 100.
select c.first_name,o.order_id,o.total from customers c
inner join orders o on c.customer_id = o.customer_id
where c.country = 'USA' AND total > 100

ğŸ‘‰ Napisz zapytanie, ktÃ³re zwrÃ³ci:

name (nazwa produktu)

category

stock_status:

'In Stock' jeÅ›li quantity â‰¥ 1

'Out of Stock' jeÅ›li quantity = 0

'Not Tracked' jeÅ›li brak wpisu w inventory (czyli NULL)

SELECT p.name, p.category, 
  CASE
    WHEN i.quantity >= 1 THEN 'In stock'
    WHEN i.quantity = 0 THEN 'Out of Stock'
    ELSE 'Not Tracked'
  END AS stock_status
FROM products p
LEFT JOIN inventory i
  ON p.product_id = i.product_id
ORDER BY p.category, p.name;
			
Zadanie: PokaÅ¼ peÅ‚nÄ… listÄ™ pracownikÃ³w, czyli:

jeÅ›li ktoÅ› byÅ‚ tylko w 2024 â†’ pokaÅ¼ go

jeÅ›li tylko w 2025 â†’ teÅ¼ pokaÅ¼

jeÅ›li w obu â†’ pokaÅ¼ dane z obu lat

âœ… Wynik ma zawieraÄ‡ kolumny:

employee_id

name_2024

name_2025

ğŸ“Œ ZakÅ‚adamy brak FULL OUTER JOIN w silniku â€” zrÃ³b to rÄ™cznie przez UNION, LEFT i RIGHT JOIN jak trzeba.

WyÅ›wietl listÄ™ pracownikÃ³w, ktÃ³rzy zarabiajÄ… wiÄ™cej niÅ¼ inni pracownicy.
Wynik ma zawieraÄ‡:

e1.name â€“ pracownik z wyÅ¼szÄ… pensjÄ…

e2.name â€“ pracownik z niÅ¼szÄ… pensjÄ…

e1.salary, e2.salary

select e1.name,e1.salary,e2.name,e2.salary,e1.salary - e2.salary as salary_diff from employees e1
inner join employees e2
on e1.employee_id <> e2.employee_id
where e1.salary > e2.salary
order by e1.salary - e2.salary desc

ğŸ‘‰ Napisz zapytanie, ktÃ³re zwrÃ³ci:

first_name

country

total_spent (czyli suma total z zamÃ³wieÅ„)

ğŸ“Œ UwzglÄ™dnij tylko klientÃ³w, ktÃ³rzy zrobili wiÄ™cej niÅ¼ 3 zamÃ³wienia
ğŸ“Œ Posortuj wynik malejÄ…co po total_spent

SELECT 
  c.first_name, 
  c.country, 
  SUM(o.total) AS total_spent
FROM customers c
INNER JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.first_name, c.country
HAVING COUNT(*) > 3
ORDER BY total_spent DESC;

SELECT 
  r1.user_id AS user_1, 
  r2.user_id AS user_2, 
  r1.movie_id,
  r1.rating AS rating_1,
  r2.rating AS rating_2,
  ABS(r1.rating - r2.rating) AS rating_diff
FROM ratings r1
JOIN ratings r2
  ON r1.movie_id = r2.movie_id
  AND r1.user_id < r2.user_id
WHERE ABS(r1.rating - r2.rating) <= 1
ORDER BY rating_diff DESC;

select p1.product_name as product_1, p2.product_name as product_2, p1.price as price_1, p2.price as price_2
p1.category, p1.price - p2.price as price_diff from products p1
join products p2
on p1.product_id < p2.product_id AND p1.category = p2.category
WHERE ABS(p1.price - p2.price) <= 2
order by price_diff desc 

SELECT c.name, SUM(o.total) AS total_spent
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.name
ORDER BY total_spent DESC
LIMIT 1;

select e.region, sum(amount) as total_sales, (select  avg(amount) from sales
group by region) as avg_employee_sales
from sales

